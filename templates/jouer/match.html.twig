{# templates/jouer/match.html.twig #}
{% extends 'base.html.twig' %}

{% block title %}Matchmaking{% endblock %}

{% block body %}
  <img src="{{ asset('bottom.png') }}" alt="Décoration" class="form-page-decoration">

  {# expected context:
     - my_team: Character[]
     - my_team_id: int
     - opponent (optional): User
     - opponent_team (optional): Character[]
  #}

  <div class="match-page">
    <div class="players-names">
      <span class="player-name gold-animated">{{ app.user.username }}</span>
      <span class="vs-label">VS</span>
      {% if opponent is defined and opponent %}
        <span class="player-name gold-animated">{{ opponent.username }}</span>
      {% else %}
        <span id="mm-waiting" class="player-name">searching…</span>
      {% endif %}
    </div>

    <div class="team-avatars">
      {# === TEAM 1 === #}
      {% set tanks1 = my_team|filter(c => c.role and c.role.name|lower == 'tank') %}
      {% for tank in tanks1 %}
        <div class="avatar-container team1-tank{% if loop.index0 > 0 %} offset-{{ loop.index0 }}{% endif %}">
          <img src="{{ asset('uploads/images/' ~ tank.imageName) }}" alt="{{ tank.name }}" class="avatar" title="{{ tank.name }}">
        </div>
      {% endfor %}

      {% set dps1 = my_team|filter(c => c.role and c.role.name|lower in ['dps','damage']) %}
      {% for dps in dps1 %}
        <div class="avatar-container team1-dps{% if loop.index0 > 0 %} offset-{{ loop.index0 }}{% endif %}">
          <img src="{{ asset('uploads/images/' ~ dps.imageName) }}" alt="{{ dps.name }}" class="avatar" title="{{ dps.name }}">
        </div>
      {% endfor %}

      {% set heals1 = my_team|filter(c => c.role and c.role.name|lower in ['heal','healer']) %}
      {% for heal in heals1 %}
        <div class="avatar-container team1-heal{% if loop.index0 > 0 %} offset-{{ loop.index0 }}{% endif %}">
          <img src="{{ asset('uploads/images/' ~ heal.imageName) }}" alt="{{ heal.name }}" class="avatar" title="{{ heal.name }}">
        </div>
      {% endfor %}

      {# === TEAM 2 (server-rendered when matched) === #}
      {% if opponent_team is defined and opponent_team %}
        {% set tanks2 = opponent_team|filter(c => c.role and c.role.name|lower == 'tank') %}
        {% for tank in tanks2 %}
          <div class="avatar-container team2-tank{% if loop.index0 > 0 %} offset-{{ loop.index0 }}{% endif %}">
            <img src="{{ asset('uploads/images/' ~ tank.imageName) }}" alt="{{ tank.name }}" class="avatar" title="{{ tank.name }}">
          </div>
        {% endfor %}

        {% set dps2 = opponent_team|filter(c => c.role and c.role.name|lower in ['dps','damage']) %}
        {% for dps in dps2 %}
          <div class="avatar-container team2-dps{% if loop.index0 > 0 %} offset-{{ loop.index0 }}{% endif %}">
            <img src="{{ asset('uploads/images/' ~ dps.imageName) }}" alt="{{ dps.name }}" class="avatar" title="{{ dps.name }}">
          </div>
        {% endfor %}

        {% set heals2 = opponent_team|filter(c => c.role and c.role.name|lower in ['heal','healer']) %}
        {% for heal in heals2 %}
          <div class="avatar-container team2-heal{% if loop.index0 > 0 %} offset-{{ loop.index0 }}{% endif %}">
            <img src="{{ asset('uploads/images/' ~ heal.imageName) }}" alt="{{ heal.name }}" class="avatar" title="{{ heal.name }}">
          </div>
        {% endfor %}
      {% endif %}
    </div>

    <div class="match-info">
      <form id="battle-form" method="post" action="{{ path('jouer_battle') }}">
        <input type="hidden" name="opponentId" id="opponentId" value="{% if opponent is defined and opponent %}{{ opponent.id }}{% endif %}">
        <input type="hidden" name="matchSeed" id="matchSeed" value="">

        {% if opponent is defined and opponent %}
          <button type="submit" class="play-btn match-btn">Lancer la bataille</button>
        {% else %}
          <div id="searching-section">
            <button type="button" id="play-suggested" class="play-btn match-btn" style="display:none">Jouer contre l'équipe proposée</button>
            <button type="button" id="cancel-mm" class="btn btn-secondary">Annuler</button>
            <div id="mm-status" class="alert alert-info" style="margin-top:.75rem">Recherche d'adversaire en cours…</div>
          </div>
        {% endif %}
      </form>
    </div>
  </div>

  {% if opponent is not defined or not opponent %}
<script>
(function () {
  if (window.__WAT_MM_ACTIVE) return;
  window.__WAT_MM_ACTIVE = true;

  const joinUrl     = "{{ path('jouer_mm_join', {id: my_team_id}) }}";
  const cancelUrl   = "{{ path('jouer_mm_cancel') }}";
  const processUrl  = "{{ path('jouer_mm_process') }}";
  const statusUrl   = "{{ path('jouer_mm_status') }}";

  const waitingEl = document.getElementById('mm-waiting');
  const statusEl  = document.getElementById('mm-status');
  const playBtn   = document.getElementById('play-suggested');
  const cancelBtn = document.getElementById('cancel-mm');
  const oppInput  = document.getElementById('opponentId');
  const seedInput = document.getElementById('matchSeed');
  const form      = document.getElementById('battle-form');

  let timer = null;
  let stopped = false;
  let inFlight = false;
  let tickCount = 0;

  async function joinOnce() {
    try {
      // Join exactly once; backend reads team from {id} in the URL
      await fetch(joinUrl, {
        method: 'POST',
        headers: {'X-Requested-With': 'XMLHttpRequest'},
        credentials: 'same-origin'
      });
    } catch (e) {
      // If already in queue, backend may 400. Keep going and just poll status.
      console.debug('join failed (continuing to poll status):', e);
    }
  }

  function start() {
    if (!timer) timer = setInterval(tick, 2000);
  }
  function stop() {
    if (timer) clearInterval(timer);
    timer = null;
    window.__WAT_MM_ACTIVE = false;
  }

  async function tick() {
    if (stopped || inFlight) return;
    inFlight = true;
    tickCount++;

    // Nudge the server processing every 3 ticks
    if (tickCount % 3 === 0) {
      try {
        await fetch(processUrl, {
          method: 'POST',
          headers: {'X-Requested-With': 'XMLHttpRequest'},
          credentials: 'same-origin'
        });
      } catch {}
    }

    try {
      const r = await fetch(statusUrl, {
        headers: {'X-Requested-With': 'XMLHttpRequest'},
        credentials: 'same-origin'
      });
      const d = await r.json();
      handleStatus(d);
    } catch (e) {
      if (statusEl) statusEl.textContent = 'Erreur réseau, nouvelle tentative…';
    } finally {
      inFlight = false;
    }
  }

  function handleStatus(d) {
    switch (d.status) {
      case 'SEARCHING':
        if (waitingEl) waitingEl.textContent = 'searching…';
        if (statusEl)  statusEl.textContent  =
          'Recherche d\'adversaire en cours…' + (d.waiting_time != null ? ` (${d.waiting_time}s)` : '');
        if (d.suggest_random_user) {
          if (waitingEl) waitingEl.textContent = 'random';
          if (oppInput)  oppInput.value = d.suggest_random_user;
          if (playBtn)   playBtn.style.display = '';
        } else {
          if (playBtn)   playBtn.style.display = 'none';
        }
        break;

      case 'MATCH_FOUND':
        if (statusEl) statusEl.textContent = 'Adversaire trouvé!';
        
        // Update opponent name in the VS section
        if (waitingEl) {
          waitingEl.textContent = d.match.opponent_username;
          waitingEl.className = 'player-name gold-animated';
        }
        
        // Update the form with opponent data AND seed
        if (oppInput) oppInput.value = d.match.opponent_id;
        if (seedInput && d.match.seed) seedInput.value = d.match.seed;

        // Hide search controls
        if (playBtn) playBtn.style.display = 'none';
        if (cancelBtn) cancelBtn.style.display = 'none';
        
        // Hide searching section and show battle button
        const searchingSection = document.getElementById('searching-section');
        if (searchingSection) {
          searchingSection.style.display = 'none';
          
          // Create and show the battle button
          const battleButton = document.createElement('button');
          battleButton.type = 'submit';
          battleButton.className = 'play-btn match-btn';
          battleButton.textContent = 'Lancer la bataille';
          battleButton.style.marginTop = '1rem';
          form.appendChild(battleButton);
        }
        
        stop();
        break;

      case 'MATCH_RESULT_PENDING':
        stop();
        announcePending(d.match);
        break;

      case 'NOT_IN_QUEUE':
      default:
        // Idle; keep polling to catch a late match or manual join
        if (waitingEl) waitingEl.textContent = '';
        if (playBtn)   playBtn.style.display = 'none';
        break;
    }
  }

  function announcePending(match) {
    if (!match || !match.id) return;
    const wrap = document.createElement('div');
    wrap.className = 'combat-pending-notification';
    wrap.innerHTML = `
      <div class="pending-combat-card">
        <div class="pending-header">
          <h3>⚔️ Combat Terminé</h3>
          <p>Voulez-vous voir le déroulement ?</p>
        </div>
        <div class="pending-actions">
          <button class="btn-view-combat" data-id="${match.id}"><i class="fas fa-eye"></i> Voir le combat</button>
          <button class="btn-skip-combat" data-id="${match.id}"><i class="fas fa-forward"></i> Passer</button>
        </div>
      </div>`;
    document.body.appendChild(wrap);

    wrap.querySelector('.btn-view-combat')?.addEventListener('click', async (e) => {
      const id = e.currentTarget.getAttribute('data-id');
      wrap.remove();
      if (window.gameInterface?.showCombatVisualization) {
        await window.gameInterface.showCombatVisualization(id);
      }
    });

    wrap.querySelector('.btn-skip-combat')?.addEventListener('click', async (e) => {
      const id = e.currentTarget.getAttribute('data-id');
      wrap.remove();
      showSimpleMatchResult(id);
    });
  }

  async function showSimpleMatchResult(id) {
    try {
      const r = await fetch(`/api/matchmaking/match/${id}`);
      const m = await r.json();
      const msg = m.is_winner ? 'Victoire' : 'Défaite';
      if (window.showNotification) window.showNotification(msg, m.is_winner ? 'success' : 'error');
    } catch {}
  }

  cancelBtn?.addEventListener('click', async () => {
    stopped = true;
    stop();
    try {
      await fetch(cancelUrl, {
        method: 'POST',
        headers: {'X-Requested-With': 'XMLHttpRequest'},
        credentials: 'same-origin'
      });
    } finally {
      if (statusEl)  statusEl.textContent  = 'Recherche annulée.';
      if (waitingEl) waitingEl.textContent = '';
      if (playBtn)   playBtn.style.display = 'none';
    }
  });

  playBtn?.addEventListener('click', () => form?.submit());

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) stop();
    else if (!stopped) start();
  });
  window.addEventListener('beforeunload', stop);

  joinOnce().finally(start);
})();
</script>
{% endif %}

{% endblock %}
